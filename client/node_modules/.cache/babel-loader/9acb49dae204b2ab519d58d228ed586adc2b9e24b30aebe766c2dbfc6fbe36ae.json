{"ast":null,"code":"// src/services/mockChatService.js\n// Mock service để test frontend không cần backend\n\nimport { mockConversations, mockMessages, mockCurrentUser, mockUsers } from './mockData';\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// In-memory storage for mock data\nlet conversations = [...mockConversations];\nlet messages = {\n  ...mockMessages\n};\nconst mockChatService = {\n  getConversations: async () => {\n    await delay(500);\n    return conversations;\n  },\n  createPrivateConversation: async userId => {\n    await delay(500);\n\n    // Kiểm tra xem conversation đã tồn tại chưa\n    const existing = conversations.find(conv => !conv.isGroup && conv.members.includes(userId));\n    if (existing) return existing;\n\n    // Tạo conversation mới\n    const otherUser = mockUsers.find(u => u._id === userId);\n    const newConv = {\n      _id: `conv-${Date.now()}`,\n      isGroup: false,\n      otherUser: otherUser,\n      members: [mockCurrentUser._id, userId],\n      lastMessage: null,\n      unreadCount: 0\n    };\n    conversations.unshift(newConv);\n    messages[newConv._id] = [];\n    return newConv;\n  },\n  createGroupConversation: async groupData => {\n    await delay(500);\n    const newGroup = {\n      _id: `group-${Date.now()}`,\n      isGroup: true,\n      name: groupData.name,\n      members: [mockCurrentUser._id, ...groupData.memberIds],\n      lastMessage: null,\n      unreadCount: 0,\n      createdBy: mockCurrentUser._id,\n      createdAt: new Date().toISOString()\n    };\n    conversations.unshift(newGroup);\n    messages[newGroup._id] = [];\n    return newGroup;\n  },\n  updateGroup: async (conversationId, groupData) => {\n    await delay(500);\n    conversations = conversations.map(conv => conv._id === conversationId ? {\n      ...conv,\n      ...groupData\n    } : conv);\n    return conversations.find(c => c._id === conversationId);\n  },\n  addGroupMembers: async (conversationId, memberIds) => {\n    await delay(500);\n    conversations = conversations.map(conv => {\n      if (conv._id === conversationId) {\n        return {\n          ...conv,\n          members: [...new Set([...conv.members, ...memberIds])]\n        };\n      }\n      return conv;\n    });\n    return conversations.find(c => c._id === conversationId);\n  },\n  leaveGroup: async conversationId => {\n    await delay(500);\n    conversations = conversations.filter(c => c._id !== conversationId);\n    delete messages[conversationId];\n    return {\n      success: true\n    };\n  },\n  getMessages: async conversationId => {\n    await delay(500);\n    return messages[conversationId] || [];\n  },\n  sendMessage: async (conversationId, content, type = 'text') => {\n    await delay(300);\n    const newMessage = {\n      _id: `msg-${Date.now()}`,\n      conversationId,\n      senderId: mockCurrentUser._id,\n      sender: mockCurrentUser,\n      content,\n      type,\n      status: 'sent',\n      createdAt: new Date().toISOString()\n    };\n\n    // Thêm vào messages\n    if (!messages[conversationId]) {\n      messages[conversationId] = [];\n    }\n    messages[conversationId].push(newMessage);\n\n    // Cập nhật lastMessage trong conversation\n    conversations = conversations.map(conv => {\n      if (conv._id === conversationId) {\n        return {\n          ...conv,\n          lastMessage: newMessage\n        };\n      }\n      return conv;\n    });\n\n    // Simulate status updates sau 1s\n    setTimeout(() => {\n      messages[conversationId] = messages[conversationId].map(msg => msg._id === newMessage._id ? {\n        ...msg,\n        status: 'delivered'\n      } : msg);\n    }, 1000);\n    setTimeout(() => {\n      messages[conversationId] = messages[conversationId].map(msg => msg._id === newMessage._id ? {\n        ...msg,\n        status: 'read'\n      } : msg);\n    }, 2000);\n    return newMessage;\n  },\n  markMessagesAsRead: async (conversationId, messageIds) => {\n    await delay(200);\n    if (messages[conversationId]) {\n      messages[conversationId] = messages[conversationId].map(msg => messageIds.includes(msg._id) ? {\n        ...msg,\n        status: 'read'\n      } : msg);\n    }\n    return {\n      success: true\n    };\n  },\n  uploadFile: async (file, conversationId) => {\n    await delay(1000);\n    return {\n      url: URL.createObjectURL(file),\n      fileName: file.name,\n      fileSize: file.size\n    };\n  },\n  searchMessages: async (conversationId, query) => {\n    await delay(500);\n    const convMessages = messages[conversationId] || [];\n    return convMessages.filter(msg => msg.content.toLowerCase().includes(query.toLowerCase()));\n  }\n};\nexport default mockChatService;","map":{"version":3,"names":["mockConversations","mockMessages","mockCurrentUser","mockUsers","delay","ms","Promise","resolve","setTimeout","conversations","messages","mockChatService","getConversations","createPrivateConversation","userId","existing","find","conv","isGroup","members","includes","otherUser","u","_id","newConv","Date","now","lastMessage","unreadCount","unshift","createGroupConversation","groupData","newGroup","name","memberIds","createdBy","createdAt","toISOString","updateGroup","conversationId","map","c","addGroupMembers","Set","leaveGroup","filter","success","getMessages","sendMessage","content","type","newMessage","senderId","sender","status","push","msg","markMessagesAsRead","messageIds","uploadFile","file","url","URL","createObjectURL","fileName","fileSize","size","searchMessages","query","convMessages","toLowerCase"],"sources":["D:/chat_app/client/src/services/mockChatService.js"],"sourcesContent":["// src/services/mockChatService.js\r\n// Mock service để test frontend không cần backend\r\n\r\nimport { mockConversations, mockMessages, mockCurrentUser, mockUsers } from './mockData';\r\n\r\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n// In-memory storage for mock data\r\nlet conversations = [...mockConversations];\r\nlet messages = { ...mockMessages };\r\n\r\nconst mockChatService = {\r\n  getConversations: async () => {\r\n    await delay(500);\r\n    return conversations;\r\n  },\r\n\r\n  createPrivateConversation: async (userId) => {\r\n    await delay(500);\r\n    \r\n    // Kiểm tra xem conversation đã tồn tại chưa\r\n    const existing = conversations.find(\r\n      conv => !conv.isGroup && conv.members.includes(userId)\r\n    );\r\n    \r\n    if (existing) return existing;\r\n    \r\n    // Tạo conversation mới\r\n    const otherUser = mockUsers.find(u => u._id === userId);\r\n    const newConv = {\r\n      _id: `conv-${Date.now()}`,\r\n      isGroup: false,\r\n      otherUser: otherUser,\r\n      members: [mockCurrentUser._id, userId],\r\n      lastMessage: null,\r\n      unreadCount: 0\r\n    };\r\n    \r\n    conversations.unshift(newConv);\r\n    messages[newConv._id] = [];\r\n    \r\n    return newConv;\r\n  },\r\n\r\n  createGroupConversation: async (groupData) => {\r\n    await delay(500);\r\n    \r\n    const newGroup = {\r\n      _id: `group-${Date.now()}`,\r\n      isGroup: true,\r\n      name: groupData.name,\r\n      members: [mockCurrentUser._id, ...groupData.memberIds],\r\n      lastMessage: null,\r\n      unreadCount: 0,\r\n      createdBy: mockCurrentUser._id,\r\n      createdAt: new Date().toISOString()\r\n    };\r\n    \r\n    conversations.unshift(newGroup);\r\n    messages[newGroup._id] = [];\r\n    \r\n    return newGroup;\r\n  },\r\n\r\n  updateGroup: async (conversationId, groupData) => {\r\n    await delay(500);\r\n    \r\n    conversations = conversations.map(conv =>\r\n      conv._id === conversationId\r\n        ? { ...conv, ...groupData }\r\n        : conv\r\n    );\r\n    \r\n    return conversations.find(c => c._id === conversationId);\r\n  },\r\n\r\n  addGroupMembers: async (conversationId, memberIds) => {\r\n    await delay(500);\r\n    \r\n    conversations = conversations.map(conv => {\r\n      if (conv._id === conversationId) {\r\n        return {\r\n          ...conv,\r\n          members: [...new Set([...conv.members, ...memberIds])]\r\n        };\r\n      }\r\n      return conv;\r\n    });\r\n    \r\n    return conversations.find(c => c._id === conversationId);\r\n  },\r\n\r\n  leaveGroup: async (conversationId) => {\r\n    await delay(500);\r\n    \r\n    conversations = conversations.filter(c => c._id !== conversationId);\r\n    delete messages[conversationId];\r\n    \r\n    return { success: true };\r\n  },\r\n\r\n  getMessages: async (conversationId) => {\r\n    await delay(500);\r\n    \r\n    return messages[conversationId] || [];\r\n  },\r\n\r\n  sendMessage: async (conversationId, content, type = 'text') => {\r\n    await delay(300);\r\n    \r\n    const newMessage = {\r\n      _id: `msg-${Date.now()}`,\r\n      conversationId,\r\n      senderId: mockCurrentUser._id,\r\n      sender: mockCurrentUser,\r\n      content,\r\n      type,\r\n      status: 'sent',\r\n      createdAt: new Date().toISOString()\r\n    };\r\n    \r\n    // Thêm vào messages\r\n    if (!messages[conversationId]) {\r\n      messages[conversationId] = [];\r\n    }\r\n    messages[conversationId].push(newMessage);\r\n    \r\n    // Cập nhật lastMessage trong conversation\r\n    conversations = conversations.map(conv => {\r\n      if (conv._id === conversationId) {\r\n        return {\r\n          ...conv,\r\n          lastMessage: newMessage\r\n        };\r\n      }\r\n      return conv;\r\n    });\r\n    \r\n    // Simulate status updates sau 1s\r\n    setTimeout(() => {\r\n      messages[conversationId] = messages[conversationId].map(msg =>\r\n        msg._id === newMessage._id\r\n          ? { ...msg, status: 'delivered' }\r\n          : msg\r\n      );\r\n    }, 1000);\r\n    \r\n    setTimeout(() => {\r\n      messages[conversationId] = messages[conversationId].map(msg =>\r\n        msg._id === newMessage._id\r\n          ? { ...msg, status: 'read' }\r\n          : msg\r\n      );\r\n    }, 2000);\r\n    \r\n    return newMessage;\r\n  },\r\n\r\n  markMessagesAsRead: async (conversationId, messageIds) => {\r\n    await delay(200);\r\n    \r\n    if (messages[conversationId]) {\r\n      messages[conversationId] = messages[conversationId].map(msg =>\r\n        messageIds.includes(msg._id)\r\n          ? { ...msg, status: 'read' }\r\n          : msg\r\n      );\r\n    }\r\n    \r\n    return { success: true };\r\n  },\r\n\r\n  uploadFile: async (file, conversationId) => {\r\n    await delay(1000);\r\n    \r\n    return {\r\n      url: URL.createObjectURL(file),\r\n      fileName: file.name,\r\n      fileSize: file.size\r\n    };\r\n  },\r\n\r\n  searchMessages: async (conversationId, query) => {\r\n    await delay(500);\r\n    \r\n    const convMessages = messages[conversationId] || [];\r\n    return convMessages.filter(msg =>\r\n      msg.content.toLowerCase().includes(query.toLowerCase())\r\n    );\r\n  }\r\n};\r\n\r\nexport default mockChatService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}